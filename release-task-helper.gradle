/*
 * Copyright 2023 Thoughtworks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import com.github.jk1.license.filter.*
import com.github.jk1.license.render.*
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

buildscript {
  repositories {
    gradlePluginPortal()
    mavenCentral()
  }

  dependencies {
    classpath localGroovy()
    classpath project.taskHelperDeps.gradleLicenseReport
  }
}

class GitHubRepository {
  String owner
  String repo

  String token
}

class Report {
  String outputDir
  List<Project> projects
  List<String> configurations = ["runtimeClasspath"]
  List<String> excludeGroups = []
  List<String> excludes = []
  boolean excludeOwnGroup = true
  boolean excludeBoms = true
  def importers = []
}

class GoCDPluginExtension {

  String id
  String pluginVersion
  String goCdVersion
  String name
  String description
  String vendorName
  String vendorUrl
  List<String> targetOs = []

  boolean prerelease = true
  boolean prereleaseDryrun = true

  Project pluginProject
  Task[] assetsToRelease

  final GitHubRepository githubRepo
  final Report licenseReport

  @javax.inject.Inject
  GoCDPluginExtension(ObjectFactory objectFactory) {
    githubRepo = objectFactory.newInstance(GitHubRepository)
    licenseReport = objectFactory.newInstance(Report)
  }

  String fullVersion(Object projectOrGit) {
    def git = projectOrGit instanceof Project ? projectOrGit.ext.git : projectOrGit
    git.distVersion() ? "${pluginVersion}-${git.distVersion()}" : pluginVersion
  }

  void githubRepo(Action<? super GitHubRepository> action) {
    action.execute(githubRepo)
  }

  void licenseReport(Action<? super Report> action) {
    action.execute(licenseReport)
  }
}

class ReleaseTask extends DefaultTask {
  private static final def HEADER_USER_AGENT = 'gocd-gradle-github-release-plugin'
  private static final def GITHUB_API_BASE_URL = "https://api.github.com"
  private static final def GITHUB_API_ACCEPT_HEADER = "application/vnd.github.v3+json"

  @Input GoCDPluginExtension gocdPlugin = project.extensions.gocdPlugin
  @Input Object git = project.extensions.extraProperties.git

  @TaskAction
  release() {
    def sha256Sums = gocdPlugin.assetsToRelease*.outputs*.files*.files.flatten().findAll { File it -> it.name.matches(".*\\.(SHA-256|SHA256)") }

    if (sha256Sums.empty) {
      logger.debug "No assets to release, skipping release."
      return
    }

    def path = "/repos/${gocdPlugin.githubRepo.owner}/${gocdPlugin.githubRepo.repo}/releases"

    def lastCommit = git.gitRevision()
    def lastTag = git.getLastTag(gocdPlugin.prerelease)
    def changelogHeader = lastTag ? "### Changelog ${lastTag}..${lastCommit.substring(0, 7)}" : "### Changelog"
    def changeLog = git.getCommitsSinceLastTag(lastTag).replaceAll("\"", "")
    def supportedGoCDVersionNote = "**Note:** *Supported GoCD server version: ${gocdPlugin.goCdVersion} or above.*"
    def checksumNote = """**SHA256 Checksums**\n```\n${
      sha256Sums.collect({ File eachFile -> eachFile.getText("utf-8").trim() }).join("\n")
    }\n```""".trim()
    def tagName = gocdPlugin.prerelease ? "${gocdPlugin.fullVersion(git)}-exp" : gocdPlugin.fullVersion(git)

    def postBody = [
      tag_name        : "v${tagName}".toString(),
      target_commitish: git.gitRevision().toString(),
      name            : "${gocdPlugin.prerelease ? 'Experimental: ' : ''}${gocdPlugin.fullVersion(git)}".toString(),
      body            : """\n$changelogHeader\n\n${changeLog}\n\n${
        supportedGoCDVersionNote
        checksumNote
      }""".stripIndent().trim().toString(),
      prerelease      : gocdPlugin.prerelease,
      draft           : gocdPlugin.prerelease && gocdPlugin.prereleaseDryrun,
    ]

    logger.quiet "Creating ${postBody.draft ? 'experimental draft ' : postBody.prerelease ? 'experimental ' : ''}release $tagName..."

    ((HttpURLConnection) new URL(GITHUB_API_BASE_URL + path).openConnection() as HttpURLConnection).with({
      requestMethod = 'POST'
      doOutput = true
      setRequestProperty('User-Agent', HEADER_USER_AGENT)
      setRequestProperty('Authorization', "token ${gocdPlugin.githubRepo.token}")
      setRequestProperty('Accept', GITHUB_API_ACCEPT_HEADER)
      setRequestProperty('Content-Type', 'application/json')

      def body = new JsonBuilder(postBody).toString()
      outputStream.withWriter("UTF-8") { writer -> writer << body }

      def logMessage = "POST ${url}\n" +
        " > User-Agent: ${getRequestProperty('User-Agent')}\n" +
        " > Authorization: (not shown)\n" +
        " > Accept: ${getRequestProperty('Accept')}\n" +
        " > body: $body\n"
      logger.debug "$logMessage"

      def result
      try {
        result = inputStream.text
        if (responseCode >= 300) {
          throw toException(it, logMessage, result)
        }
      } catch (Exception e) {
        throw toException(it, logMessage, null, e)
      }

      def resultJson = new JsonSlurper().parseText(result)
      try {
        if (gocdPlugin.assetsToRelease != null) {
          logger.quiet "Uploading assets to release $tagName..."
          postAssets(resultJson.upload_url)
        }
      } finally {
        // If we're doing a dry-run, try and delete the draft release regardless of whether asset upload succeeded or failed.
        if (postBody.draft) {
          logger.quiet "Release was OK, deleting draft release $tagName..."
          deleteRelease(resultJson.id.toString())
        }
      }
    })
  }

  def deleteRelease(String releaseId) {
    def path = "/repos/${gocdPlugin.githubRepo.owner}/${gocdPlugin.githubRepo.repo}/releases/${releaseId}"

    ((HttpURLConnection) new URL(GITHUB_API_BASE_URL + path).openConnection() as HttpURLConnection).with({
      requestMethod = 'DELETE'
      setRequestProperty('User-Agent', HEADER_USER_AGENT)
      setRequestProperty('Authorization', "token ${gocdPlugin.githubRepo.token}")
      setRequestProperty('Accept', GITHUB_API_ACCEPT_HEADER)

      def logMessage = "DELETE ${url}\n" +
        " > User-Agent: ${getRequestProperty('User-Agent')}\n" +
        " > Authorization: (not shown)\n" +
        " > Accept: ${getRequestProperty('Accept')}\n"
      logger.debug "$logMessage"

      try {
        def result = inputStream.text
        if (responseCode >= 300) {
          throw toException(it, logMessage, result)
        }
      } catch (Exception e) {
        throw toException(it, logMessage, null, e)
      }
    })
  }

  def postAssets(String uploadUrl) {
    gocdPlugin.assetsToRelease.each { Task assetTask ->

      assetTask.outputs.files.forEach { File file ->
        def name = file.name

        def upload = uploadUrl.replace('{?name,label}', "?name=${name}&label=${name}")
        logger.debug "upload url: ${upload}"

        if (file.exists()) {

          (new URL(upload).openConnection() as HttpURLConnection).with({
            requestMethod = 'POST'
            doOutput = true
            setRequestProperty('User-Agent', HEADER_USER_AGENT)
            setRequestProperty('Authorization', "token ${gocdPlugin.githubRepo.token}")
            setRequestProperty('Accept', GITHUB_API_ACCEPT_HEADER)
            setRequestProperty('Content-Type', 'application/octet-stream')

            outputStream.withStream { os -> os << file.bytes }

            def logMessage = "POST ${url}\n" +
              " > User-Agent: ${getRequestProperty('User-Agent')}\n" +
              " > Authorization: (not shown)\n" +
              " > Accept: ${getRequestProperty('Accept')}\n"

            try {
              def result = inputStream.text
              if (responseCode >= 300) {
                throw toException(it, logMessage, result)
              } else {
                def json = new JsonSlurper().parseText(result)
                logger.debug "$json"
              }
            } catch (Exception e) {
              throw toException(it, logMessage, null, e)
            }
          })
        }
      }
    }
  }

  def toException(HttpURLConnection connection, String logMessage, String result, Throwable cause = null) {
    logger.error "Error in $logMessage"
    logger.info 'Response headers: \n' + connection.headerFields.collect { "< $it" }.join('\n')
    logger.info result
    new GradleScriptException("Error while creating release: ${connection.responseMessage}. Result = $result", cause)
  }
}

project.rootProject.ext.defaultAllowedLicenses = writeTempFile("./default-allowed-licenses.json")
project.rootProject.ext.licenseNormalizerBundle = writeTempFile("./normalizing-licenses-bundle.json")

class GoCDPlugin implements Plugin<Project> {
  void apply(Project project) {
    project.configure(project) {
      project.allprojects { apply plugin: com.github.jk1.license.LicenseReportPlugin }
    }

    GoCDPluginExtension gocdPluginExtension = project.extensions.create('gocdPlugin', GoCDPluginExtension)

    project.afterEvaluate {
      initializeLicenseReporting(gocdPluginExtension, project)

      project.tasks.register('showLicenseReportErrors') { DefaultTask thisTask ->
        def checkLicenseTask = project.tasks.named('checkLicense')
        checkLicenseTask.finalizedBy(thisTask)

        doLast {

          def reportText = checkLicenseTask.get().outputs.files.singleFile.text
          def reportContents = new JsonSlurper().parseText(reportText)

          if (reportContents.containsKey('dependenciesWithoutAllowedLicenses')) {
            if (!reportContents.dependenciesWithoutAllowedLicenses.empty) {
                println "Failed to validate licenses for the following modules:"
                println reportText
            }
          } else {
            throw new GradleException("Could not find key `dependenciesWithoutAllowedLicenses` in license report: ${reportText}")
          }
        }
      }

      project.tasks.register('githubRelease', ReleaseTask) { ReleaseTask thisTask ->
        thisTask.dependsOn project.allprojects*.tasks*.findByName('assemble').findAll { it != null }
      }
    }
  }

  private void initializeLicenseReporting(GoCDPluginExtension gocdPlugin, Project project) {
    Project pluginProject = gocdPlugin.pluginProject

    if (pluginProject == null) return

    pluginProject.tasks.assemble.dependsOn("checkLicense")
    project.extensions.licenseReport.outputDir = gocdPlugin.licenseReport.outputDir ?: "${project.layout.buildDirectory.get()}/license"
    pluginProject.extensions.licenseReport.outputDir = gocdPlugin.licenseReport.outputDir ?: "${project.layout.buildDirectory.get()}/license"
    pluginProject.extensions.licenseReport.projects = gocdPlugin.licenseReport.projects ?: project.allprojects
    pluginProject.extensions.licenseReport.configurations = gocdPlugin.licenseReport.configurations ?: ["runtimeClasspath"]
    pluginProject.extensions.licenseReport.excludeGroups = gocdPlugin.licenseReport.excludeGroups
    pluginProject.extensions.licenseReport.excludeOwnGroup = gocdPlugin.licenseReport.excludeOwnGroup
    pluginProject.extensions.licenseReport.excludeBoms = gocdPlugin.licenseReport.excludeBoms
    pluginProject.extensions.licenseReport.excludes = gocdPlugin.licenseReport.excludes
    pluginProject.extensions.licenseReport.renderers = [new TextReportRenderer()]
    pluginProject.extensions.licenseReport.importers = gocdPlugin.licenseReport.importers
    pluginProject.extensions.licenseReport.filters = new LicenseBundleNormalizer(bundlePath: project.rootProject.licenseNormalizerBundle)
    pluginProject.extensions.licenseReport.allowedLicensesFile = project.rootProject.defaultAllowedLicenses

    gocdPlugin.assetsToRelease.findAll { jar ->
      if (jar == null) return
      jar.dependsOn jar.project.tasks.named('generateLicenseReport')
      jar.into('license-report') {
        from "$pluginProject.extensions.licenseReport.outputDir/THIRD-PARTY-NOTICES.txt"
      }
    }
  }
}

private File writeTempFile(String fileName) {
  def content = (buildscript.sourceFile ? buildscript.sourceFile.toURI() : buildscript.sourceURI).resolve(fileName).toURL().text
  def name = fileName.substring(0, fileName.lastIndexOf('.'))
  def ext = fileName.substring(fileName.lastIndexOf('.'))
  File file = File.createTempFile(name, ext)
  file.write content
  file.deleteOnExit()
  file
}

apply plugin: GoCDPlugin
